
import React, { useEffect, useRef } from 'react';
import { 
  FEATURE_LAYER_URL, 
  MAINTENANCE_FEATURE_LAYER_URL, 
  STATUS_FIELD_NAME, 
  GEOCODER_URL,
  NEW_POLE_FIELD,
  OLD_POLE_FIELD,
  POLE_NUMBER_FIELD
} from '../constants';

interface MapContainerProps {
  activeLayerType: 'transfer' | 'maintenance';
  onMessage: (msg: string) => void;
  actionsRef: React.MutableRefObject<any>;
}

const MapContainer: React.FC<MapContainerProps> = ({ activeLayerType, onMessage, actionsRef }) => {
  const mapDivRef = useRef<HTMLDivElement>(null);
  const mapRef = useRef<any>(null);
  const viewRef = useRef<any>(null);
  const activeLayerRef = useRef<any>(null);
  const searchWidgetRef = useRef<any>(null);
  const statusFieldInfoRef = useRef<any>(null);

  const statusRenderer = {
    type: "unique-value",
    field: STATUS_FIELD_NAME,
    defaultSymbol: {
      type: "simple-marker",
      color: "#6b7280",
      outline: { color: "#ffffff", width: 1 }
    },
    uniqueValueInfos: [
      {
        value: "Ready",
        symbol: { type: "simple-marker", color: "#16a34a", outline: { color: "#ffffff", width: 1 } },
        label: "Ready"
      },
      {
        value: "Blocked",
        symbol: { type: "simple-marker", color: "#dc2626", outline: { color: "#ffffff", width: 1 } },
        label: "Blocked"
      },
      {
        value: "Completed",
        symbol: { type: "simple-marker", color: "#eab308", outline: { color: "#ffffff", width: 1 } },
        label: "Completed"
      }
    ]
  };

  const getPopupActions = () => ([
    { title: "Set Ready", id: "set-ready", className: "esri-icon-check-mark" },
    { title: "Set Blocked", id: "set-blocked", className: "esri-icon-close" },
    { title: "Set Completed", id: "set-completed", className: "esri-icon-checkbox-checked" }
  ]);

  // Surface errors strictly as requested
  const surfaceArcGISError = (errorObj: any, fallback = 'Unknown update error.') => {
    if (!errorObj) return fallback;
    const code = errorObj.code || errorObj.error?.code;
    const message = errorObj.message || errorObj.error?.message || errorObj.description;
    const details = errorObj.details || errorObj.error?.details;
    const parts = [
      code ? `Code: ${code}` : null,
      message ? `Message: ${message}` : null,
      details ? `Details: ${JSON.stringify(details)}` : null
    ].filter(Boolean);
    return parts.length ? parts.join('\n') : fallback;
  };

  const validateStatusValue = (rawStatus: string) => {
    const fieldInfo = statusFieldInfoRef.current;
    if (!fieldInfo) return { validated: rawStatus, note: 'No schema loaded; using raw status.' };
    
    const domain = fieldInfo.domain;
    if (domain && domain.codedValues && Array.isArray(domain.codedValues)) {
      const match = domain.codedValues.find((cv: any) => cv.name === rawStatus || cv.code === rawStatus);
      if (match) return { validated: match.code, note: `Mapped status to domain code for ${rawStatus}` };
    }
    
    const fieldType = fieldInfo.type;
    if (fieldType && (fieldType.toLowerCase().includes('double') || fieldType.toLowerCase().includes('integer'))) {
      const asNumber = Number(rawStatus);
      return { validated: Number.isNaN(asNumber) ? rawStatus : asNumber, note: 'Numeric status field detected.' };
    }
    return { validated: rawStatus, note: 'Default validation path.' };
  };

  const updateStatusOnLayer = async (objectId: number, newStatus: string) => {
    const layer = activeLayerRef.current;
    if (!layer) return;

    const { validated } = validateStatusValue(newStatus);
    const payload = {
      updateFeatures: [{
        attributes: {
          OBJECTID: objectId,
          [STATUS_FIELD_NAME]: validated
        }
      }]
    };

    try {
      const result = await layer.applyEdits(payload);
      const updateResults = result.updateFeatureResults || result.updateResults || [];
      const updateResult = updateResults[0];

      if (updateResult && !updateResult.error) {
        onMessage(`SUCCESS: Status updated to ${newStatus}.`);
        layer.refresh();
      } else {
        const err = surfaceArcGISError(updateResult?.error);
        onMessage(`FAILED to update pole ${objectId}.\n${err}`);
      }
    } catch (error: any) {
      onMessage(`Network Error: ${error.message}`);
    }
  };

  const addNewPoleAtLocation = async (lat: number, lng: number) => {
    const layer = activeLayerRef.current;
    if (!layer) return;

    const payload = {
      addFeatures: [{
        geometry: { type: "point", longitude: lng, latitude: lat },
        attributes: { [STATUS_FIELD_NAME]: 'Ready' }
      }]
    };

    try {
      const result = await layer.applyEdits(payload);
      const addResult = result.addFeatureResults?.[0];
      if (addResult?.success) {
        onMessage('SUCCESS: New pole added at your location!');
        layer.refresh();
        
        // Zoom to the new feature
        const { Query } = await getArcGISModules();
        const query = new Query({
          objectIds: [addResult.objectId],
          outFields: ["*"],
          returnGeometry: true
        });
        const queryRes = await layer.queryFeatures(query);
        if (queryRes.features.length > 0) {
          viewRef.current.goTo({ target: queryRes.features[0].geometry, zoom: 17 });
          viewRef.current.popup.open({ 
            features: [queryRes.features[0]], 
            location: queryRes.features[0].geometry 
          });
        }
      } else {
        const err = surfaceArcGISError(addResult?.error, 'Unknown add error. Check layer settings.');
        onMessage(`FAILED to add new pole.\n${err}`);
      }
    } catch (error: any) {
      onMessage(`Network Error: ${error.message}`);
    }
  };

  const getArcGISModules = () => {
    return new Promise<any>((resolve) => {
      // @ts-ignore
      require([
        'esri/layers/FeatureLayer',
        'esri/rest/support/Query',
        'esri/widgets/Search',
        'esri/request'
      ], (FeatureLayer: any, Query: any, Search: any, esriRequest: any) => {
        resolve({ FeatureLayer, Query, Search, esriRequest });
      });
    });
  };

  const refreshSearchSources = async (layer: any) => {
    if (!searchWidgetRef.current) return;
    
    const geocoderSource = {
      name: 'Address',
      placeholder: 'Search address',
      singleLineFieldName: 'SingleLine',
      url: GEOCODER_URL
    };

    const searchFields = [NEW_POLE_FIELD, OLD_POLE_FIELD, POLE_NUMBER_FIELD, 'Road', 'Town']
      .filter(f => layer.fields.some((lf: any) => lf.name === f));

    const displayField = searchFields.includes(OLD_POLE_FIELD) ? OLD_POLE_FIELD : (searchFields[0] || POLE_NUMBER_FIELD);

    const featureSource = {
      layer,
      searchFields,
      displayField,
      suggestionTemplate: `{${NEW_POLE_FIELD}} / {${OLD_POLE_FIELD}} - {Road}, {Town}`,
      exactMatch: false,
      outFields: ['*'],
      name: 'Poles',
      placeholder: 'Pole #, Road, or Town'
    };

    searchWidgetRef.current.sources = [featureSource, geocoderSource];
  };

  const switchLayer = async (type: string) => {
    const { FeatureLayer, esriRequest } = await getArcGISModules();
    if (activeLayerRef.current) {
      mapRef.current.remove(activeLayerRef.current);
    }

    const url = type === 'maintenance' ? MAINTENANCE_FEATURE_LAYER_URL : FEATURE_LAYER_URL;
    
    // Fetch schema for validation
    try {
      const response = await esriRequest(`${url}?f=json`, { responseType: 'json' });
      statusFieldInfoRef.current = response.data.fields?.find((f: any) => f.name === STATUS_FIELD_NAME) || null;
    } catch (err) {
      console.warn('Failed to fetch layer metadata', err);
    }

    const layer = new FeatureLayer({
      url,
      outFields: ['*'],
      renderer: statusRenderer,
      popupTemplate: {
        title: 'Pole: {expression/poleLabel}',
        content: `
          <div class="space-y-3 text-sm p-1">
            <div class="bg-gray-50 p-3 rounded-lg border border-gray-100">
               <div class="font-bold text-[#2D6A4F] text-base">{Road}, {Town}</div>
               <div class="text-xs text-gray-500 uppercase font-semibold mt-1">Asset Location</div>
            </div>
            <div class="grid grid-cols-2 gap-2 mt-4">
              <div class="p-2 border rounded-md">
                 <div class="text-[10px] text-gray-400 uppercase font-bold">New Pole ID</div>
                 <div class="font-mono text-gray-900">{${NEW_POLE_FIELD}}</div>
              </div>
              <div class="p-2 border rounded-md">
                 <div class="text-[10px] text-gray-400 uppercase font-bold">Old Pole ID</div>
                 <div class="font-mono text-gray-900">{${OLD_POLE_FIELD}}</div>
              </div>
            </div>
            <div class="mt-4 flex items-center justify-between p-3 bg-white border border-gray-200 rounded-lg shadow-sm">
               <div>
                  <div class="text-[10px] text-gray-400 uppercase font-bold">Current Status</div>
                  <div class="font-bold text-gray-800">{Status}</div>
               </div>
               <div class="h-6 w-6 rounded-full border-2 border-white shadow-md bg-status-{Status}"></div>
            </div>
            <p class="text-[10px] text-gray-500 font-medium italic mt-2 text-center">Use actions below to update workflow status.</p>
          </div>
        `,
        expressionInfos: [{
          name: 'poleLabel',
          expression: `IIF(!IsEmpty($feature.${NEW_POLE_FIELD}), $feature.${NEW_POLE_FIELD}, $feature.${OLD_POLE_FIELD})`
        }],
        actions: getPopupActions()
      }
    });

    activeLayerRef.current = layer;
    mapRef.current.add(layer);
    
    layer.load().then(() => {
      refreshSearchSources(layer);
    });
  };

  useEffect(() => {
    // @ts-ignore
    require([
      'esri/config',
      'esri/Map',
      'esri/views/MapView',
      'esri/identity/OAuthInfo',
      'esri/identity/IdentityManager',
      'esri/core/reactiveUtils'
    ], (esriConfig: any, Map: any, MapView: any, OAuthInfo: any, IdentityManager: any, reactiveUtils: any) => {
      
      const info = new OAuthInfo({
        portalUrl: 'https://www.arcgis.com',
        appId: 'c6dKp7cbBFCn4m8k',
        popup: false,
        redirectUri: 'https://kevincopeland42.github.io/Kevin/'
      });

      IdentityManager.registerOAuthInfos([info]);

      IdentityManager.checkSignInStatus(`${info.portalUrl}/sharing`)
        .catch(() => IdentityManager.getCredential(`${info.portalUrl}/sharing`))
        .then(() => {
          const map = new Map({ basemap: 'streets-navigation-vector' });
          const view = new MapView({
            container: mapDivRef.current,
            map,
            center: [-71.0589, 42.3601],
            zoom: 12,
            padding: { top: 160, left: 0, right: 0, bottom: 0 },
            popup: {
              dockEnabled: true,
              dockOptions: { buttonEnabled: false, breakpoint: false }
            }
          });

          mapRef.current = map;
          viewRef.current = view;

          // Init search widget (headless)
          getArcGISModules().then(({ Search }) => {
            const search = new Search({
              view,
              container: document.createElement('div'),
              includeDefaultSources: false,
              popupEnabled: true
            });
            searchWidgetRef.current = search;
            switchLayer('transfer');
          });

          // Handle Popup actions
          reactiveUtils.when(() => view.popup, () => {
            view.popup.on('trigger-action', (event: any) => {
              const feature = view.popup.selectedFeature;
              if (!feature) return;
              const objectId = feature.attributes?.OBJECTID;
              if (!objectId) return;

              const statusMap: Record<string, string> = {
                'set-ready': 'Ready',
                'set-blocked': 'Blocked',
                'set-completed': 'Completed'
              };
              
              if (statusMap[event.action.id]) {
                updateStatusOnLayer(objectId, statusMap[event.action.id]);
              }
            });
          });

          // Expose actions
          actionsRef.current = {
            geolocate: () => {
              if (!navigator.geolocation) {
                onMessage('Geolocation is not supported.');
                return;
              }
              navigator.geolocation.getCurrentPosition(pos => {
                view.goTo({ center: [pos.coords.longitude, pos.coords.latitude], zoom: 15 });
              });
            },
            handleAddNewPole: () => {
              if (!navigator.geolocation) {
                onMessage('GPS unavailable.');
                return;
              }
              onMessage('Accessing GPS location...');
              navigator.geolocation.getCurrentPosition(pos => {
                addNewPoleAtLocation(pos.coords.latitude, pos.coords.longitude);
              });
            },
            handleSearch: (val: string) => {
              searchWidgetRef.current?.search(val);
            }
          };
        });
    });
  }, []);

  useEffect(() => {
    if (mapRef.current) {
      switchLayer(activeLayerType);
    }
  }, [activeLayerType]);

  return <div ref={mapDivRef} className="fixed inset-0 w-full h-full z-0" />;
};

export default MapContainer;




